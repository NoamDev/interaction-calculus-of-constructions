// Interaction Calculus of Constructions
// =====================================

// Type
// ----

data Term
  = (Lam bod)
  | (App fun arg)
  | (Bri bod)
  | (Ann val typ)
  | (Var idx)
  | (Ref uid exp)

// Interactions
// ------------

(APP fun arg) = match fun = (Reduce fun) {
  Lam: (Reduce (fun.bod arg))
  Bri: (Bri λx(APP (fun.bod (Lam λ$k(x))) (ANN $k arg)))
  Ref: (APP fun.exp arg)
  var: (App var arg)
}

(ANN val typ) = match typ = (Reduce typ) {
  Lam: (Lam λx(ANN (APP val $k) (typ.bod (Bri λ$k(x)))))
  Bri: (Reduce (typ.bod val))
  Ref: (ANN val typ.exp)
  var: (Ann val var)
}

// Evaluation
// ----------

(Reduce term) = match term {
  App: (APP term.fun term.arg)
  Ann: (ANN term.val term.typ)
  val: val
}

(Expand term) = match term = (Reduce term) {
  Ref: (Expand term.exp)
  val: val
}

(Normal term dep) = match term = (Reduce term) {
  Lam: (Lam λx(Normal (term.bod (Var dep)) (+ dep 1)))
  App: (APP (Normal term.fun dep) (Normal term.arg dep))
  Bri: (Bri λx(Normal (term.bod (Var dep)) (+ dep 1)))
  Ann: (ANN (Normal term.val dep) (Normal term.typ dep))
  Ref: (Normal term.exp dep)
  Var: (Var term.idx)
}

// Program
// -------

// type Program r = ∀(logs: [String]) ([String], r)

(pure x) = λlogs
  (logs, x)

(bind a b) = λlogs
  let (a_logs, a_result) = (a logs)
  (b a_result a_logs)

(log msg) = λlogs
  ((LCons msg logs), 0)

(run a) = (a [])

// Equality
// --------

(Equal a b dep) = match (Compare a b dep) {
  +: 1
  0: (Compare (Expand a) (Expand b) dep)
}

(Compare (Lam a.bod)       (Lam b.bod)       dep) = (Equal (a.bod (Var dep)) (b.bod (Var dep)) (+ 1 dep))
(Compare (App a.fun a.arg) (App b.fun b.arg) dep) = (& (Equal a.fun b.fun dep) (Equal a.arg b.arg dep))
(Compare (Bri a.bod)       (Bri b.bod)       dep) = (Equal (a.bod (Var dep)) (b.bod (Var dep)) (+ 1 dep))
(Compare (Ann a.val a.typ) b                 dep) = (Equal a.val b dep)
(Compare a                 (Ann b.val b.typ) dep) = (Equal a b.val dep)
(Compare (Ref a.uid a.exp) (Ref b.uid b.exp) dep) = (== a.uid b.uid)
(Compare (Var a.idx)       (Var b.idx)       dep) = (== a.idx b.idx)
(Compare a                 b                 dep) = 0

// Checking
// --------

data Maybe
  = None
  | (Some value)

(Group (Some val) b) = #err{val b}
(Group None       b) = b

(Infer term dep) = 
  (bind (log (Join ["Infer: " (Show term dep)])) λx
  match term {
    Lam: (Infer (term.bod (Var dep)) (+ 1 dep))
    App: (bind (Infer term.fun dep) λfun (bind (Infer term.arg dep) λarg (pure (& fun arg))))
    Bri: (Infer (term.bod (Var dep)) (+ 1 dep))
    Ann: (Check term.val term.typ dep)
    Ref: (pure 1)
    Var: (pure 1)
  })

(Check term type dep) =
  let type = (Reduce type)
  (bind (log (Join ["Check: " (Show term dep) " :: " (Show type dep)])) λx
  match type {
    Bri: (Infer (type.bod term) dep)
    Ann: (Check term type.val dep)
    typ:
      let term = (Expand term)
      (bind (log (Join ["Again: " (Show term dep) " :: " (Show type dep)])) λx
      match term {
        Ann: match eq = (Equal term.typ type dep) {
          0: (bind (log (Join ["Mismatch: " (Show type dep) " != " (Show term.typ dep)])) λx(pure 0))
          +: (Infer term.val dep)
        }
        Lam: (bind (log (Join ["NonFunLam: " (Show (Lam term.bod) dep) " :: " (Show typ dep)])) λx(pure 0))
        exp: (pure 1)
      })
  })

(AnnCheck term) = match term {
  Ann: 
    let (logs, result) = (run (Check term.val (Expand term.typ) 0))
    [logs, result]
  Ref: (AnnCheck term.exp)
  exp: "untyped"
}

// Stringification
// ---------------

(Concat SNil         ys) = ys
(Concat (SCons x xs) ys) = (SCons x (Concat xs ys))

(Join LNil)         = ""
(Join (LCons x xs)) = (Concat x (Join xs))

(U60.show n) = (U60.show.go n SNil)
(U60.show.go n res) = match k = (< n 10) {
  0: (U60.show.go (/ n 10) (SCons (+ '0' (% n 10)) res))
  +: (SCons (+ '0' n) res)
}

(Show term dep) = match term {
  Lam: (Join ["λx" (U60.show dep) " " (Show (term.bod (Var dep)) (+ dep 1))])
  App: (Join ["(" (Show term.fun dep) " " (Show term.arg dep) ")"])
  Bri: (Join ["θx" (U60.show dep) " " (Show (term.bod (Var dep)) (+ dep 1))])
  Ann: (Join ["{" (Show term.val dep) " : " (Show term.typ dep) "}"])
  Var: match (== term.idx (- 0 1)) { 0: (Join ["x" (U60.show term.idx)]); +: "*" }
  Ref: (NameOf term.uid)
}

// TODO: optimize Show and remove this
(Quote term dep) = match term {
  Lam: (Lam λx(Quote (term.bod (Var dep)) (+ dep 1)))
  App: (App (Quote term.fun dep) (Quote term.arg dep))
  Bri: (Bri λx(Quote (term.bod (Var dep)) (+ dep 1)))
  Ann: (Ann (Quote term.val dep) (Quote term.typ dep))
  Var: (Var term.idx)
  Ref: (Ref term.uid term.exp)
}

// Utils
// -----

(NameOf uid) = (Get uid Names)

(Get n list) = match n {
  0: match list {
    LNil: 0
    LCons: list.head
  }
  +: match list {
    LNil: 0
    LCons: (Get n-1 list.tail)
  }
}

// Terms
// -----

Set = (Var (- 0 1))

//Names = []

//T = (Ref 0 (Lam λt (Lam λf t)))
//F = (Ref 1 (Lam λt (Lam λf f)))

//Main = (Equal (App (Var 0) (Lam λt (Lam λf t))) (App (Var 0) T) 0 0)
